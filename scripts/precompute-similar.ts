import { createCanvas } from "@napi-rs/canvas"
import { writeFileSync, readFileSync, existsSync } from "fs"
import { join } from "path"
import { SingleBar } from "cli-progress"
import { UNICODE_CATEGORIES, generateCharactersForCategory } from "../lib/unicode-data"

const JSON_OUTPUT_PATH = join(process.cwd(), "lib", "similar-characters.json")
const TS_OUTPUT_PATH = join(process.cwd(), "lib", "similar-characters.ts")

interface SimilarCharactersData {
  [codePoint: number]: number[]
}

async function generateCharacterImage(char: string): Promise<string> {
  const canvas = createCanvas(400, 400)
  const ctx = canvas.getContext("2d")

  // White background
  ctx.fillStyle = "#ffffff"
  ctx.fillRect(0, 0, 400, 400)

  // Black text
  ctx.fillStyle = "#000000"
  ctx.font = "240px sans-serif"
  ctx.textAlign = "center"
  ctx.textBaseline = "middle"
  ctx.fillText(char, 200, 200)

  // Convert to base64 data URL
  return canvas.toDataURL("image/png")
}

async function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms))
}

async function findSimilarCharacters(codePoint: number, char: string, retries = 3): Promise<number[]> {
  const imageData = await generateCharacterImage(char)
  
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      // Add delay between requests to avoid rate limiting (except first attempt)
      if (attempt > 0) {
        const backoffDelay = Math.min(1000 * Math.pow(2, attempt - 1), 10000) // Exponential backoff, max 10s
        await sleep(backoffDelay)
      }

      const response = await fetch("https://shapecatcher.com/engine/recognize", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: `file=${encodeURIComponent(imageData)}`,
      })

      if (!response.ok) {
        // Retry on 5xx errors, fail immediately on 4xx errors
        if (response.status >= 500 && attempt < retries - 1) {
          const hex = codePoint.toString(16).toUpperCase().padStart(4, "0")
          console.warn(`U+${hex}: API returned ${response.status}, retrying (${attempt + 1}/${retries})...`)
          continue
        }
        throw new Error(`API returned status ${response.status}`)
      }

      const html = await response.text()

      // Extract Unicode characters using regex (same as in route.ts)
      const regex = /<span class='detail_character_unicode'[^>]*>([^<]+)<\/span>/g
      const unicodeChars: string[] = []
      let match

      while ((match = regex.exec(html)) !== null) {
        unicodeChars.push(match[1])
      }

      // Convert character strings to codePoints, skip the first (it's the character itself)
      const similarCodePoints = unicodeChars
        .slice(1)
        .map((char) => char.codePointAt(0))
        .filter((cp): cp is number => cp !== undefined && cp !== codePoint) // Filter out undefined and self

      return similarCodePoints
    } catch (error) {
      // If this is the last attempt, throw the error
      if (attempt === retries - 1) {
        throw error
      }
      // Otherwise, continue to retry
      continue
    }
  }
  
  // Should never reach here, but TypeScript needs this
  return []
}

function loadExistingData(): SimilarCharactersData {
  if (existsSync(JSON_OUTPUT_PATH)) {
    try {
      const content = readFileSync(JSON_OUTPUT_PATH, "utf-8")
      return JSON.parse(content)
    } catch (error) {
      console.warn("Failed to load existing data, starting fresh:", error)
      return {}
    }
  }
  return {}
}

function saveData(data: SimilarCharactersData) {
  // Save JSON file
  writeFileSync(JSON_OUTPUT_PATH, JSON.stringify(data, null, 2), "utf-8")

  // Generate TypeScript file with single-line format
  const entries = Object.entries(data)
    .sort(([a], [b]) => parseInt(a) - parseInt(b))
    .map(([codePoint, similar]) => {
      const similarStr = JSON.stringify(similar)
      return `  ${codePoint}: ${similarStr}`
    })
    .join(",\n")

  const tsContent = `// This file is auto-generated by scripts/precompute-similar.ts
// Do not edit manually

export const SIMILAR_CHARACTERS: Record<number, number[]> = {
${entries}
} as Record<number, number[]>
`
  writeFileSync(TS_OUTPUT_PATH, tsContent, "utf-8")
}

function parseLimit(): number | null {
  const args = process.argv.slice(2)
  const limitIndex = args.findIndex((arg) => arg === "--limit" || arg === "-n" || arg === "-l")
  
  if (limitIndex !== -1) {
    const limitValue = args[limitIndex + 1]
    if (limitValue) {
      const limit = parseInt(limitValue, 10)
      if (!isNaN(limit) && limit > 0) {
        return limit
      }
    }
  }
  
  // Also check for --limit=N or -n=N format
  for (const arg of args) {
    const match = arg.match(/^(--limit|-n|-l)=(\d+)$/)
    if (match) {
      const limit = parseInt(match[2], 10)
      if (!isNaN(limit) && limit > 0) {
        return limit
      }
    }
  }
  
  return null
}

async function main() {
  const limit = parseLimit()
  
  console.log("Starting pre-computation of similar characters...")
  if (limit) {
    console.log(`Limit: Processing up to ${limit} new characters this run.\n`)
  } else {
    console.log("This may take a very long time for all characters.\n")
  }

  const data = loadExistingData()
  const processedCount = Object.keys(data).length
  console.log(`Found ${processedCount} already processed characters.`)

  // Collect all characters
  const allCharacters: Array<{ codePoint: number; char: string }> = []
  for (const category of UNICODE_CATEGORIES) {
    const chars = generateCharactersForCategory(category)
    for (const char of chars) {
      allCharacters.push({ codePoint: char.codePoint, char: char.char })
    }
  }

  // Filter out already processed characters for progress tracking
  const charactersToProcess = allCharacters.filter(({ codePoint }) => !data[codePoint])
  const totalToProcess = limit ? Math.min(limit, charactersToProcess.length) : charactersToProcess.length

  console.log(`Total characters: ${allCharacters.length}`)
  console.log(`Remaining to process: ${charactersToProcess.length}`)
  if (limit) {
    console.log(`Will process up to ${limit} new characters this run.\n`)
  } else {
    console.log()
  }

  // Create progress bar
  const progressBar = new SingleBar({
    format: 'Progress |{bar}| {percentage}% | {value}/{total} | ETA: {eta}s | {char}',
    barCompleteChar: '\u2588',
    barIncompleteChar: '\u2591',
    hideCursor: true
  })

  progressBar.start(totalToProcess, 0, {
    char: 'Starting...'
  })

  let processed = 0
  let skipped = 0
  let errors = 0

  for (const { codePoint, char } of allCharacters) {
    // Skip if already processed
    if (data[codePoint]) {
      skipped++
      continue
    }

    // Stop if we've reached the limit
    if (limit && processed >= limit) {
      progressBar.stop()
      console.log(`\nReached limit of ${limit} characters. Stopping.`)
      break
    }

    processed++
    const hex = codePoint.toString(16).toUpperCase().padStart(4, "0")
    
    // Update progress bar
    progressBar.update(processed, {
      char: `U+${hex} (${char})`
    })

    try {
      const similar = await findSimilarCharacters(codePoint, char)
      data[codePoint] = similar
      
      // Add a small delay between requests to avoid rate limiting
      await sleep(100)
    } catch (error) {
      const hex = codePoint.toString(16).toUpperCase().padStart(4, "0")
      console.error(`Error finding similar characters for U+${hex}:`, error)
      data[codePoint] = []
      errors++
    }

    // Save incrementally after each character
    saveData(data)
  }

  progressBar.stop()
  console.log("\n" + "=".repeat(50))
  console.log("Pre-computation complete!")
  console.log(`Total characters: ${allCharacters.length}`)
  console.log(`Processed this run: ${processed}`)
  console.log(`Skipped (already done): ${skipped}`)
  console.log(`Errors: ${errors}`)
  if (limit && processed >= limit) {
    console.log(`\nNote: Processed ${limit} characters as requested. Run again to continue.`)
  }
  console.log(`Output saved to: ${TS_OUTPUT_PATH}`)
}

main().catch((error) => {
  console.error("Fatal error:", error)
  process.exit(1)
})
